# SafePi
This is the SafePi V2 project, a secure peripheral free home security IoT device utilizing Bluetooth Low Energy communication for device provisioning. This project was done as part of a California State University, Monterey Bay Computer Science Capstone by Elliot Shabram, Joseph Carey, Tomas Diaz Wahl, and Liam Cristescu and won the CS Faculty Choice award. The original project can be found [HERE](https://github.com/Twilliams073/SafePiGeneral). Note that none of the original code or libraries were used for this project. The only part inherited from the previous project was the SafePi name. 

### Project Breakdown
1. SafePi-embedded -> Python application and setup instructions for operating system and service.
2. SafePi-Web -> NodeJS server application for central management of login, Oauth2 token generation and validation, and connection to the database.
3. SafePiConnect -> Android application for user interaction, login, provisioning of device, and monitoring SafePi statuses.

### Future Work
This project serves as an excellent platform for future capstones, or anyone who might want to take over and build upon the work done by the capstone team members listed above. This section will lay out potential future directions and improvements.

1. _MQTT protocol for efficient and secure communication_. This protocol is designed for low-power IoT devices such as this. If more research had been done into communication protocols specifically, this would have been the protocol chosen for the project. An MQTT server can be easily set up with Node, and a client to match is even easier on the Python embedded application. This would cut down the heavy cost of the multi-handshake TLS communication. It might also allow encrypted communication without the use of certificate authorities, as is the case for TLS, or at least allow encrypted communication more easily without having to purchase the safepi.org domain name. The domain name was purchased after dealing with many issues with self-signed certificates, and it is not recommended to use self-signed for that reason.
2. _Add a locking mechanism to the physical device_, as well as controls in the Android app. This would require an external power solution to initiate a solenoid. The Rpi does not have a way to power such a device, and should not be attempted, as this could potentially burn out some GPIO.
3. Remove Firebase from the server. Firebase is doing a bit of the work behind the scenes, but this is work our server application could be doing. By removing Firebase, and by hosting our own database, we remove all outside parties from the Safepi ecosystem. The database is not a priority, as that gives us quite a bit of access, but there is still a limit that we reached while testing, causing us to make another account as a backup. The db could be hosted on the same server for simplicity. Perhaps CSUMB will have their stuff together by then and have server access for their students, as they have been talking about for some time now. Look into this before falling back to free AWS ec2 as we did for this project. 
4. _Make a list of locks and a way to add them._ Currently, only one lock sensor is connected to the device for demonstration purposes. This could be more of a physical solution that allows the user to more easily connect to the Rpi itself. The application could read whether there is anything connected to those ports and only report on the locks that are currently connected.
5. _Wireless lock sensors and/or locking mechanisms._ Something like an esp32 could be used to control the actual lock and reading mechanism, which would be reported back to the device over the same BLE protocol used for communication with the application. This would not only require programming and powering a separate device, but it would also require some kind of provisioning process for the sensors themselves. The provisioning could be fairly simple, with something like a button on the devices that can be clicked or held for a kind of pairing process. Remember that BLE does not require pairing, so pairing here would be more permanent, and be used to gain the ability to report to the Rpi indefinitely. This might be tricky, as you cannot use a camera to scan a QR, and passing credentials over BLE would require some sort of encryption, and that shouldn't be hard coded. If I were doing this project (Elliot), I'd look into adding RFID, or something of that nature. That may also eliminate QR scanning. All of that said, this option is quite a bit more advanced and might make a whole capstone in itself.
6. _Add a camera with face detection and face unlock._ This is not too hard, as the Rpi is very friendly to adding cameras. The camera could stream to the server and then to the app so that a live feed could be seen of one's home. A motion sensor would likely have to be added. Face detection is not all that difficult with Python these days, and face recognition isn't too bad either.

I'm sure there are many other directions and ideas, but these were the ones on our radar as far as stretch goals and whatnot. If you need to set up a meeting, contact Elliot Shabram, the owner of this organization. I am more than happy to explain all aspects of this project (Elliot). Good luck.
